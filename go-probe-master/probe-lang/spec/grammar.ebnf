(* PROBE Language Grammar Specification *)
(* EBNF notation — compatible with XGrammar/SGLang constrained generation *)
(* Design: regular or weakly context-free for zero-overhead constrained decoding *)

program = { declaration } ;

(* === Declarations === *)

declaration = fn_decl
            | struct_decl
            | enum_decl
            | trait_decl
            | impl_decl
            | agent_decl
            | resource_decl
            | type_decl
            | use_decl
            | mod_decl ;

fn_decl = [ "pub" ] "fn" IDENT "(" [ param_list ] ")" [ "->" type_expr ] block ;

struct_decl = [ "pub" ] "struct" IDENT "{" [ field_list ] "}" ;

enum_decl = [ "pub" ] "enum" IDENT "{" enum_variant { "," enum_variant } [ "," ] "}" ;

trait_decl = [ "pub" ] "trait" IDENT "{" { trait_method } "}" ;

impl_decl = "impl" [ IDENT "for" ] type_expr "{" { fn_decl } "}" ;

agent_decl = [ "pub" ] "agent" IDENT "{"
               [ "state" "{" field_list "}" ]
               { msg_handler }
             "}" ;

resource_decl = [ "pub" ] "resource" IDENT "{" [ field_list ] "}" ;

type_decl = [ "pub" ] "type" IDENT "=" type_expr ";" ;

use_decl = "use" path [ "::" ( IDENT | "*" ) ] ";" ;

mod_decl = [ "pub" ] "mod" IDENT ( "{" { declaration } "}" | ";" ) ;

(* === Helpers === *)

param_list = param { "," param } [ "," ] ;
param = [ "mut" ] IDENT ":" type_expr ;

field_list = field { "," field } [ "," ] ;
field = [ "pub" ] IDENT ":" type_expr ;

enum_variant = IDENT [ "(" type_expr { "," type_expr } ")" ] ;

trait_method = "fn" IDENT "(" [ param_list ] ")" [ "->" type_expr ] ";" ;

msg_handler = "msg" IDENT "(" [ param_list ] ")" [ "->" type_expr ] block ;

path = IDENT { "::" IDENT } ;

(* === Statements === *)

statement = let_stmt
          | assign_stmt
          | return_stmt
          | for_stmt
          | while_stmt
          | break_stmt
          | continue_stmt
          | drop_stmt
          | emit_stmt
          | require_stmt
          | expr_stmt ;

let_stmt = "let" [ "mut" ] IDENT [ ":" type_expr ] "=" expression ";" ;

assign_stmt = expression assign_op expression ";" ;
assign_op = "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" | "<<=" | ">>=" ;

return_stmt = "return" [ expression ] ";" ;

for_stmt = "for" IDENT "in" expression block ;

while_stmt = "while" expression block ;

break_stmt = "break" ";" ;

continue_stmt = "continue" ";" ;

drop_stmt = "drop" IDENT ";" ;

emit_stmt = "emit" IDENT "{" [ field_init_list ] "}" ";" ;

require_stmt = "require" "(" expression [ "," expression ] ")" ";" ;

expr_stmt = expression ";" ;

(* === Expressions === *)
(* Operator precedence (low to high):
   1. ||
   2. &&
   3. == != < > <= >=
   4. |
   5. ^
   6. &
   7. << >>
   8. + -
   9. * / %
  10. prefix: - ! ~ # & *
  11. postfix: . [] () ::
*)

expression = or_expr ;

or_expr = and_expr { "||" and_expr } ;

and_expr = cmp_expr { "&&" cmp_expr } ;

cmp_expr = bitor_expr { ( "==" | "!=" | "<" | ">" | "<=" | ">=" ) bitor_expr } ;

bitor_expr = bitxor_expr { "|" bitxor_expr } ;

bitxor_expr = bitand_expr { "^" bitand_expr } ;

bitand_expr = shift_expr { "&" shift_expr } ;

shift_expr = add_expr { ( "<<" | ">>" ) add_expr } ;

add_expr = mul_expr { ( "+" | "-" ) mul_expr } ;

mul_expr = prefix_expr { ( "*" | "/" | "%" ) prefix_expr } ;

prefix_expr = ( "-" | "!" | "~" | "#" | "&" | "*" ) prefix_expr
            | postfix_expr ;

postfix_expr = primary_expr { "." IDENT [ "(" [ arg_list ] ")" ]
                             | "[" expression "]"
                             | "(" [ arg_list ] ")"
                             | "::" IDENT } ;

primary_expr = INT_LITERAL
             | FLOAT_LITERAL
             | STRING_LITERAL
             | BYTES_LITERAL
             | ADDRESS_LITERAL
             | "true" | "false" | "nil"
             | IDENT
             | "self"
             | "(" expression ")"
             | block_expr
             | if_expr
             | match_expr
             | array_expr
             | range_expr
             | move_expr
             | copy_expr
             | spawn_expr
             | send_expr
             | recv_expr ;

block_expr = block ;
block = "{" { statement } [ expression ] "}" ;

if_expr = "if" expression block [ "else" ( if_expr | block ) ] ;

match_expr = "match" expression "{" match_arm { "," match_arm } [ "," ] "}" ;
match_arm = pattern "=>" ( expression | block ) ;

pattern = "_"
        | IDENT
        | INT_LITERAL
        | STRING_LITERAL
        | "true" | "false"
        | IDENT "(" [ pattern { "," pattern } ] ")" ;

array_expr = "[" [ expression { "," expression } [ "," ] ] "]" ;

range_expr = expression ".." expression ;

move_expr = "move" expression ;

copy_expr = "copy" expression ;

spawn_expr = "spawn" IDENT "{" [ field_init_list ] "}" ;

send_expr = "send" expression expression ;

recv_expr = "recv" ;

arg_list = expression { "," expression } [ "," ] ;

field_init_list = field_init { "," field_init } [ "," ] ;
field_init = IDENT ":" expression ;

(* === Type Expressions === *)

type_expr = named_type
          | path_type
          | array_type
          | slice_type
          | ref_type
          | fn_type ;

named_type = IDENT ;

path_type = IDENT "::" IDENT { "::" IDENT } ;

array_type = "[" type_expr ";" expression "]" ;

slice_type = "[" type_expr "]" ;

ref_type = "&" [ "mut" ] type_expr ;

fn_type = "fn" "(" [ type_expr { "," type_expr } ] ")" [ "->" type_expr ] ;

(* === Lexical Tokens === *)
(* All ASCII-only — designed for BPE tokenizer alignment *)

IDENT = letter { letter | digit | "_" } ;
INT_LITERAL = digit { digit } | "0x" hex_digit { hex_digit } ;
FLOAT_LITERAL = digit { digit } "." digit { digit } ;
STRING_LITERAL = '"' { string_char } '"' ;
BYTES_LITERAL = "0x" hex_digit { hex_digit } ;
ADDRESS_LITERAL = "@" "0x" hex_digit { hex_digit } ;

letter = "a".."z" | "A".."Z" | "_" ;
digit = "0".."9" ;
hex_digit = digit | "a".."f" | "A".."F" ;
string_char = ? any ASCII char except '"' and '\' ?
            | "\" escape_char ;
escape_char = "n" | "r" | "t" | "\" | '"' | "0" ;

(* Line comment *)
LINE_COMMENT = "//" { ? any char except newline ? } ;

(* Block comment *)
BLOCK_COMMENT = "/*" { ? any char ? } "*/" ;

(* Whitespace: space, tab, newline, carriage return — ignored *)
