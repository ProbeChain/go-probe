// Copyright 2024 The ProbeChain Authors
// This file is part of the ProbeChain.
//
// The ProbeChain is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The ProbeChain is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the ProbeChain. If not, see <http://www.gnu.org/licenses/>.

package vm

import (
	"errors"
	"fmt"

	"golang.org/x/crypto/sha3"
)

// errPQCNotImplemented is the sentinel error returned by all PQC opcode stubs
// until the underlying cryptographic libraries are integrated.
var errPQCNotImplemented = errors.New("vm: PQC opcode not yet implemented")

// ---- SHA3 / Keccak256 ------------------------------------------------------

// execSHA3 computes Keccak-256 of Memory[srcAddr .. srcAddr+length) and writes
// the 32-byte digest to Memory[dstAddr .. dstAddr+32).
//
// Both the source region and the destination region must already be allocated
// in vm.memory; ErrInvalidAddress is returned otherwise.
func execSHA3(mem *Memory, dstAddr, srcAddr, length uint64) error {
	input, err := mem.ReadSlice(srcAddr, length)
	if err != nil {
		return fmt.Errorf("OpSHA3 read src: %w", err)
	}

	h := sha3.NewLegacyKeccak256()
	h.Write(input)
	digest := h.Sum(nil) // 32 bytes

	if err := mem.WriteSlice(dstAddr, digest); err != nil {
		return fmt.Errorf("OpSHA3 write dst: %w", err)
	}
	return nil
}

// ---- SHAKE256 --------------------------------------------------------------

// execSHAKE256 computes SHAKE256(Memory[srcAddr .. srcAddr+length), outLen=32)
// and writes the 32-byte output to Memory[dstAddr .. dstAddr+32).
func execSHAKE256(mem *Memory, dstAddr, srcAddr, length uint64) error {
	input, err := mem.ReadSlice(srcAddr, length)
	if err != nil {
		return fmt.Errorf("OpSHAKE256 read src: %w", err)
	}

	h := sha3.NewShake256()
	h.Write(input)

	output := make([]byte, 32)
	if _, err := h.Read(output); err != nil {
		return fmt.Errorf("OpSHAKE256 read output: %w", err)
	}

	if err := mem.WriteSlice(dstAddr, output); err != nil {
		return fmt.Errorf("OpSHAKE256 write dst: %w", err)
	}
	return nil
}

// ---- Secp256k1 recovery ----------------------------------------------------

// execSecp256k1Recover recovers the uncompressed secp256k1 public key from a
// 32-byte message hash and a 65-byte [R||S||V] signature stored in Memory.
//
// Parameters:
//   - hashAddr: address of 32 bytes (the message hash)
//   - sigAddr:  address of 65 bytes ([R:32][S:32][V:1])
//
// The recovered 65-byte public key is written to a freshly allocated region
// and its base address is returned.  On failure, a non-nil error is returned.
//
// This function delegates to the main-module crypto package's Ecrecover, which
// wraps libsecp256k1 via CGo.  To keep the vm package import-light and avoid
// the CGo dependency in tests, it uses the pure-Go sha3 path and calls
// ecrecoverPureGo, a thin shim defined below.
func execSecp256k1Recover(mem *Memory, hashAddr, sigAddr uint64) (uint64, error) {
	hashBytes, err := mem.ReadSlice(hashAddr, 32)
	if err != nil {
		return 0, fmt.Errorf("OpSecp256k1Recover read hash: %w", err)
	}
	sigBytes, err := mem.ReadSlice(sigAddr, 65)
	if err != nil {
		return 0, fmt.Errorf("OpSecp256k1Recover read sig: %w", err)
	}

	pubkey, err := ecrecoverShim(hashBytes, sigBytes)
	if err != nil {
		return 0, fmt.Errorf("OpSecp256k1Recover: %w", err)
	}

	// Allocate memory for the 65-byte uncompressed public key.
	ptr, err := mem.Alloc(65)
	if err != nil {
		return 0, fmt.Errorf("OpSecp256k1Recover alloc: %w", err)
	}
	if err := mem.WriteSlice(ptr, pubkey); err != nil {
		return 0, fmt.Errorf("OpSecp256k1Recover write pubkey: %w", err)
	}
	return ptr, nil
}

// ecrecoverShim is the actual call into the secp256k1 library.  It is declared
// as a variable so tests can replace it with a stub without CGo.
var ecrecoverShim = defaultEcrecover

// defaultEcrecover calls into go-probeum's secp256k1 package.
// The import is guarded by a build tag in production; for the vm package we
// use a pure-Go fallback (see crypto_nocgo.go / crypto_cgo.go generated by
// the build system).  Here we simply return "not implemented" so that the vm
// package compiles without the CGo dependency â€” the real implementation is
// injected at link time by the chain execution context.
func defaultEcrecover(hash, sig []byte) ([]byte, error) {
	// Placeholder: the full secp256k1 recovery requires CGo (libsecp256k1).
	// The vm package intentionally avoids a hard CGo dependency so it can be
	// used in pure-Go environments (e.g., WASM, testing without C toolchain).
	// The surrounding chain layer replaces ecrecoverShim with the real
	// implementation before constructing production VM instances.
	_ = hash
	_ = sig
	return nil, fmt.Errorf("vm: secp256k1 ecrecover: %w (inject via ecrecoverShim)", errPQCNotImplemented)
}

// ---- PQC stubs -------------------------------------------------------------
//
// The following three functions are intentional stubs.  Production integration
// requires linking the respective libraries (e.g., liboqs, cloudflare/circl).
// Each returns errPQCNotImplemented until that work is complete.

// execFalcon512Verify is the stub for the Falcon-512 signature verification
// opcode.  Parameters msgAddr, sigAddr, and pubkeyAddr are addresses of the
// respective byte arrays in the VM's linear memory.
func execFalcon512Verify(mem *Memory, msgAddr, sigAddr, pubkeyAddr uint64) (uint64, error) {
	// TODO: integrate with a Falcon-512 Go/CGo library.
	_ = mem
	_ = msgAddr
	_ = sigAddr
	_ = pubkeyAddr
	return 0, fmt.Errorf("OpFalcon512Verify: %w", errPQCNotImplemented)
}

// execMLDSAVerify is the stub for ML-DSA (CRYSTALS-Dilithium) signature
// verification.  A full implementation would call
// github.com/cloudflare/circl/sign/dilithium/mode2.Verify.
func execMLDSAVerify(mem *Memory, msgAddr, sigAddr, pubkeyAddr uint64) (uint64, error) {
	// TODO: delegate to crypto/dilithium.Verify after reading the byte slices
	// from the VM's linear memory.
	_ = mem
	_ = msgAddr
	_ = sigAddr
	_ = pubkeyAddr
	return 0, fmt.Errorf("OpMLDSAVerify: %w", errPQCNotImplemented)
}

// execSLHDSAVerify is the stub for SLH-DSA (SPHINCS+) signature verification.
// A full implementation would call into a SPHINCS+ Go binding.
func execSLHDSAVerify(mem *Memory, msgAddr, sigAddr, pubkeyAddr uint64) (uint64, error) {
	// TODO: integrate with a SPHINCS+ (SLH-DSA) library.
	_ = mem
	_ = msgAddr
	_ = sigAddr
	_ = pubkeyAddr
	return 0, fmt.Errorf("OpSLHDSAVerify: %w", errPQCNotImplemented)
}
